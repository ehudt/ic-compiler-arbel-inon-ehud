package IC.Parser;

import IC.AST.*;
import java_cup.runtime.*;

////////////////////////////////////////////
// Symbol list (terminals and non-terminals)

terminal		ASSIGN, BOOLEAN, BREAK, CLASS, COMMA;
terminal 		CONTINUE, DIVIDE, DOT, ELSE, EQUAL;
terminal 		EXTENDS, FALSE, GT, GTE, IF, INT;
terminal 		LAND, LB, LCBR, LENGTH, LNEG, LOR;
terminal 		LP, LT, LTE, MINUS, MOD, MULTIPLY;
terminal 		NEQUAL, NEW, NULL, PLUS, RB, RCBR;
terminal 		RETURN, RP, SEMI, STATIC, STRING;
terminal 		THIS, TRUE, VOID, WHILE;

terminal Integer INTEGER;
terminal String CLASS_ID, ID, QUOTE;

nonterminal Program 	program;
nonterminal Expression 	expr;
nonterminal Location	location;
nonterminal Call		call;
nonterminal StaticCall	staticCall;
nonterminal VirtualCall	virtualCall;
nonterminal BinaryOp	binop;
nonterminal UnaryOp		unop;
nonterminal Literal		literal;		

//////////////////////////
// Precedence declarations

//////////////
// The grammar

program ::= classDecl*
			{: RESULT :} 
;

classDecl ::= class CLASS [extends CLASS] '{' (field | method)* '}'
			  {: RESULT = new :}
;
			  
field ::= type ID (',' ID)* ';'
		{:RESULT:}
;
method ::= [static] (type | void) ID '(' [formals] ')' '{' stmt* '}'
		{:RESULT:}
;

formals ::= type ID (',' type ID)*
			{:RESULT:}
;

type ::= int | boolean | string | CLASS | type '[' ']'
			{:RESULT:}
;

stmt ::= location '=' expr ';'
	     {:RESULT:}
		 |
		 call ';'
		 {:RESULT:}
		 |
		 return [expr] ';'
		 {:RESULT:}
		 |
		 if '(' expr ')' stmt [else stmt]
		 {:RESULT:}
		 |
		 while '(' expr ')' stmt
		 {:RESULT:}
		 |
		 break ';'
		 {:RESULT:}
		 |
		 continue ';'
		 {:RESULT:}
		 |
		 '{' stmt* '}'
		 {:RESULT:}
		 |
		 type ID ['=' expr] ';'
		 {:RESULT:}
;		 		 		 		 
		
binop ::=	

unop ::=	MINUS:x
			{: RESULT = UnaryOps.UMINUS; :}
			|
			LNEG:x
			{: RESULT = UnaryOps.LNEG; :}
;

literal ::= INTEGER:n 
			{:  long num_val = Long.parseLong(n);
				if (num_val > (long)2147483648){
					throw new SyntaxError("Integer literal out of range"/*TODO*/);
				}
				RESULT = new Literal(/*TODO line # */, LiteralTypes.INTEGER, n); 
			:} 
			| QUOTE:s 
			{:	RESULT = new Literal(/*TODO line # */, LiteralTypes.STRING, s); :}  
			| TRUE:b
			{: 	RESULT = new Literal(/*TODO line # */, LiteralTypes.TRUE); :}
			| FALSE:b 
			{: 	RESULT = new Literal(/*TODO line # */, LiteralTypes.FALSE); :}
			| NULL:r
			{: 	RESULT = new Literal(/*TODO line # */, LiteralTypes.NULL); :}
;
