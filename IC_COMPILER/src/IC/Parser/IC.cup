package IC.Parser;

import IC.AST.*;
import java_cup.runtime.*;

////////////////////////////////////////////
// Symbol list (terminals and non-terminals)

terminal		ASSIGN, BOOLEAN, BREAK, CLASS, COMMA;
terminal 		CONTINUE, DIVIDE, DOT, ELSE, EQUAL;
terminal 		EXTENDS, FALSE, GT, GTE, IF, INT;
terminal 		LAND, LB, LCBR, LENGTH, LNEG, LOR;
terminal 		LP, LT, LTE, MINUS, MOD, MULTIPLY;
terminal 		NEQUAL, NEW, NULL, PLUS, RB, RCBR;
terminal 		RETURN, RP, SEMI, STATIC, STRING;
terminal 		THIS, TRUE, VOID, WHILE;

terminal Integer INTEGER;
terminal String CLASS_ID, ID, QUOTE;

nonterminal Program 	program;
nonterminal ICClass 	classdecl;
nonterminal List<ICClass> classList;
nonterminal List<ASTNode> fmList;
nonterminal List<Field>	fieldList;
nonterminal List<String> idList;
nonterminal Method		method;
nonterminal Formal		formal
nonterminal Type		type;
nonterminal Statement	stmt;
nonterminal Expression 	expr;
nonterminal Location	location;
nonterminal Call		call;
nonterminal StaticCall	staticCall;
nonterminal VirtualCall	virtualCall;
nonterminal BinaryOp	binop;
nonterminal UnaryOp		unop;
nonterminal Literal		literal;		

//////////////////////////
// Precedence declarations

//////////////
// The grammar

program ::= classList:c_list
			{: 
					RESULT = new Program(c_list);
			:} 
;

classList ::== classDecl:c
			   {: 
			   		RESULT = new LinkedList<ICClass>();
			   		RESULT.add(c);
			   :}
			   |
			   classList:c_list classDecl:c
			   {: 
			   		c_list.add(c);
			   		RESULT = c_list;
			   :} 

classDecl ::= CLASS CLASS_ID:c_name EXTENDS CLASS_ID:super_name LCBR fmList:l RCBR
			  {:
			  		/* TODO: Check how to join the 2 functions*/
			  		
			  		// This case handles Class declaration with Extends
			  		List <Field> fie= new LinkedList<>();
			  		List <Method> met= new LinkedList<>();
			  		for(ASTNode n:l)
			  		{
						if(n instanceof Field)
						{
							fie.add((Field)n)
						}
						else 
							if(n instanceof Method)
							{
								met.add((Method)n);
							}
							else
							{
								throw new SyntaxError("Class can contain only fields or methods"/*TODO*/);		  
							}
			  		}
			  		RESULT = new ICClass(getLine(), c_name,super_name, fie, met); 			   
			  :}
			  |
			  CLASS CLASS_ID:c_name LCBR fmList:l RCBR
			  {:
			  		// This case handless Class declaration
			 		List <Field> fie= new LinkedList<>();
			  		List <Method> met= new LinkedList<>();
			  		for(ASTNode n:l)
			  		{
						if(n instanceof Field)
						{
							fie.add((Field)n)
						}
						else 
							if(n instanceof Method)
							{
								met.add((Method)n);
							}
							else
							{
								throw new SyntaxError("Class can contain only fields or methods"/*TODO*/);		  
							}
			  		}
			  		RESULT = new ICClass(getLine(), c_name, fie, met);
			  :}
;

fmList ::= fmList:fm fieldList:fl
		   {:
		   //Left recursion fieldList
	       RETURN =
		   :}
		   |
		   fmList:fm Method:m
		   {:
		   //Left recursion Method
		   RETURN =
		   :}
		   |
		   {:
		   //Epsilon case
		   RETURN = 
		   :}
		   
		
;
			  
fieldList ::= type:t idList:id_list SEMI
		{:
		List<Field> fields=new LinkedList<>();
		for(string id: id_list)
		{
			Field f=new Field(t,id);
			fields.add(f);
		}
		RESULT = fields;
		:}
;

method ::= [static] (type | void) ID '(' [formals] ')' '{' stmt* '}'
		{:RESULT:}
;

formals ::= type ID (',' type ID)*
			{:RESULT:}
;

type ::= int | boolean | string | CLASS | type '[' ']'
			{:RESULT:}
;

stmt ::= location '=' expr ';'
	     {:RESULT:}
		 |
		 call ';'
		 {:RESULT:}
		 |
		 return [expr] ';'
		 {:RESULT:}
		 |
		 if '(' expr ')' stmt [else stmt]
		 {:RESULT:}
		 |
		 while '(' expr ')' stmt
		 {:RESULT:}
		 |
		 break ';'
		 {:RESULT:}
		 |
		 continue ';'
		 {:RESULT:}
		 |
		 '{' stmt* '}'
		 {:RESULT:}
		 |
		 type ID ['=' expr] ';'
		 {:RESULT:}
;		 		 		 		 
		
binop ::=	

unop ::=	MINUS:x
			{: RESULT = UnaryOps.UMINUS; :}
			|
			LNEG:x
			{: RESULT = UnaryOps.LNEG; :}
;

literal ::= INTEGER:n 
			{:  long num_val = Long.parseLong(n);
				if (num_val > (long)2147483648){
					throw new SyntaxError("Integer literal out of range"/*TODO*/);
				}
				RESULT = new Literal(/*TODO line # */, LiteralTypes.INTEGER, n); 
			:} 
			| QUOTE:s 
			{:	RESULT = new Literal(/*TODO line # */, LiteralTypes.STRING, s); :}  
			| TRUE:b
			{: 	RESULT = new Literal(/*TODO line # */, LiteralTypes.TRUE); :}
			| FALSE:b 
			{: 	RESULT = new Literal(/*TODO line # */, LiteralTypes.FALSE); :}
			| NULL:r
			{: 	RESULT = new Literal(/*TODO line # */, LiteralTypes.NULL); :}
;
